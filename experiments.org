* Experiments
  :PROPERTIES:
  :CUSTOM_ID: experiments
  :session:  asm-gp
  :END:
** real program repair summary

|           | LOC (in machine-code) | Pos. tests | Neg. tests | Success | GTR |
|-----------+-----------------------+------------+------------+---------+-----|
| sendmail  | 667                   | 5          | 1          |    100% |   1 |
| deroff    | 7041                  | 5          | 1          |     27% |   1 |
| nullhttpd | 6933                  | 5          | 1          |      3% |   1 |

** deroff
*** results
for the first run which found success in 3/10 runs
#+begin_src clojure
  (def target-fitness 10)
  (def max-generations 20)
  (def population-size 400)
  (def use-tournament false)
  (def max-section-size 1)
  (def good-mult 1)
  (def bad-mult 5)
  (def gcc-flags nil)
  (def baseline-path "deroff.s")
  (def good-path-path "good.path")
  (def bad-path-path "bad.path")
  (def test-dir "~/research/code/deroff/")
  (def fitness-cache-path
       (.getPath (f/file-str "~/research/code/deroff/fitness-cache.clj")))
  (def test-good "./my-test-good.sh")
  (def test-bad "./my-test-bad.sh")
#+end_src

*** method
    :PROPERTIES:
    :tangle:   test/deroff
    :results:  silent
    :session:  asm-gp
    :END:

The following steps are tangled to the =test/deroff.clj= script which can
be run from inside of the =deroff= directory using
#+begin_src sh :tangle no
  java -Xss2m -cp ../../../src/clojure/clojure.jar:../../../src/clojure-contrib/clojure-contrib.jar clojure.main ../test/deroff.clj
#+end_src

1) create the =deroff.s= file
   #+begin_src sh :tangle no
     cd deroff
     gcc -S deroff_comb.c
     mv deroff_comb.s deroff.s
   #+end_src
2) start a slime repl in the =deroff/= directory
3) load the resulting file and step into the namespace
   #+begin_src clojure
     (load-file "../src/asm-gp.clj")(in-ns 'asm-gp)
   #+end_src
4) set the GP parameters
   #+begin_src clojure
     (def target-fitness 10)
     (def max-generations 20)
     (def population-size 400)
     (def use-tournament false)
     (def max-section-size 1)
     (def good-mult 1)
     (def bad-mult 5)
     (def compiler "gcc")
     (def compiler-flags nil)
     (def baseline-path "deroff.s")
     (def good-path-path "good.path")
     (def bad-path-path "bad.path")
     (def test-timeout 2000)
     (def test-dir "~/research/code/deroff/")
     (def fitness-cache-path
          (.getPath (f/file-str "~/research/exp/deroff/fitness-cache.clj")))
     (def test-good "./my-test-good.sh")
     (def test-bad "./my-test-bad.sh")
   #+end_src
5) run 500 iterations -- note that =asm-gp-pack= must be in your path
   #+begin_src clojure
     (run-experiment
      (dorun
       (map  (fn [run]
               (do
                 (evolve baseline)
                 (let [save-dir (str "variants/" (.toString run))]
                   (s/sh "mkdir" save-dir)
                   (s/sh "asm-gp-pack" save-dir)
                   (write-obj fitness-cache-path @fitness-cache))))
             (range 500))))
   #+end_src

** s4
   :PROPERTIES:
   :blog:     t
   :type:     experiment
   :END:

*** method
    :PROPERTIES:
    :tangle:   test/s4
    :results:  silent
    :session:  asm-gp
    :END:

The following steps are tangled to the =test/s4.clj= script which can
be run from inside of the =s4= directory using
#+begin_src sh :tangle no
  java -cp ../../../src/clojure/clojure.jar:../../../src/clojure-contrib/clojure-contrib.jar clojure.main ../test/s4.clj
#+end_src

1) create the =s4.s= file
   #+begin_src sh :tangle no
     cd s4
     gcc -S s4.c
   #+end_src
2) start a slime repl in the =s4/= directory
3) load the resulting file and step into the namespace
   #+begin_src clojure
     (load-file "../src/asm-gp.clj")(in-ns 'asm-gp)
   #+end_src
4) set the GP parameters
   #+begin_src clojure
     (def target-fitness 8)
     (def max-generations 20)
     (def population-size 400)
     (def use-tournament false)
     (def max-section-size 3)
     (def good-mult 2)
     (def bad-mult 4)
     (def compiler "gcc")
     (def compiler-flags nil)
     (def baseline-path "s4.s")
     (def good-path-path "good.path")
     (def bad-path-path "bad.path")
     (def test-timeout 2000)
     (def fitness-cache-path
          (.getPath (f/file-str "~/research/exp/s4/fitness-cache.clj")))
     (def test-dir "~/research/code/s4/")
     (def test-good "./my-test-good.sh")
     (def test-bad "./my-test-bad.sh")
   #+end_src
5) run 500 iterations -- note that =asm-gp-pack= must be in your path
   #+begin_src clojure
     (run-experiment
      (dorun
       (map  (fn [run]
               (do
                 (evolve baseline)
                 (let [save-dir (str "variants/" (.toString run))]
                   (s/sh "mkdir" save-dir)
                   (s/sh "asm-gp-pack" save-dir)
                   (write-obj fitness-cache-path @fitness-cache))))
             (range 500))))
   #+end_src

** flex
   :PROPERTIES:
   :blog:     t
   :type:     experiment
   :END:

*** method
    :PROPERTIES:
    :tangle:   test/flex
    :results:  silent
    :session:  asm-gp
    :END:

The following steps are tangled to the =test/flex.clj= script which can
be run from inside of the =flex= directory using
#+begin_src sh :tangle no
  java -Xss256m -Xmx256m -cp ../../../src/clojure/clojure.jar:../../../src/clojure-contrib/clojure-contrib.jar clojure.main ../test/flex.clj
#+end_src

1) create the =flex.s= file
   #+begin_src sh :tangle no
     cd flex
     gcc -S flex_comb.c
     mv flex_comb.s flex.s
   #+end_src
2) start a slime repl in the =flex/= directory
3) load the resulting file and step into the namespace
   #+begin_src clojure
     (load-file "../src/asm-gp.clj")(in-ns 'asm-gp)
   #+end_src
4) set the GP parameters
   #+begin_src clojure
     (def target-fitness 10)
     (def max-generations 20)
     (def population-size 400)
     (def use-tournament false)
     (def max-section-size 1)
     (def good-mult 1)
     (def bad-mult 5)
     (def compiler "gcc")
     (def compiler-flags nil)
     (def baseline-path "flex.s")
     (def good-path-path "good.path")
     (def bad-path-path "bad.path")
     (def test-timeout 2000)
     (def test-dir "~/research/code/flex/")
     (def fitness-cache-path
          (.getPath (f/file-str "~/research/exp/flex/fitness-cache.clj")))
     (def test-good "./my-test-good.sh")
     (def test-bad "./my-test-bad.sh")
   #+end_src
5) run 500 iterations -- note that =asm-gp-pack= must be in your path
   #+begin_src clojure
     (run-experiment
      (dorun
       (map  (fn [run]
               (do
                 (evolve baseline)
                 (let [save-dir (str "variants/" (.toString run))]
                   (s/sh "mkdir" save-dir)
                   (s/sh "asm-gp-pack" save-dir)
                   (write-obj fitness-cache-path @fitness-cache))))
             (range 500))))
   #+end_src

** uniq
*** method
    :PROPERTIES:
    :tangle:   test/uniq
    :results:  silent
    :session:  asm-gp
    :END:

The following steps are tangled to the =test/uniq.clj= script which can
be run from inside of the =uniq= directory using
#+begin_src sh :tangle no
  java -cp ../../../src/clojure/clojure.jar:../../../src/clojure-contrib/clojure-contrib.jar clojure.main ../test/uniq.clj
#+end_src

1) create the =uniq.s= file
   #+begin_src sh :tangle no
     cd uniq
     gcc -S uniq.c
   #+end_src
2) create good and bad paths (ran good-test 10 times and bad-path 1000
   times)
3) start a slime repl in the =uniq/= directory
4) load the resulting file and step into the namespace
   #+begin_src clojure
     (load-file "../src/asm-gp.clj")(in-ns 'asm-gp)
   #+end_src
5) set the GP parameters
   #+begin_src clojure
     (def target-fitness 10)
     (def max-generations 20)
     (def population-size 400)
     (def use-tournament false)
     (def max-section-size 1)
     (def good-mult 1)
     (def bad-mult 5)
     (def gcc-flags nil)
     (def fitness-cache-path
          (.getPath (f/file-str "~/research/exp/uniq/fitness-cache.clj")))
     (def baseline-path "uniq.s")
     (def good-path-path "good.path")
     (def bad-path-path "bad.path")
     (def test-timeout 2000)
     (def test-dir "~/research/code/uniq/")
     (def test-good "./test-good.sh")
     (def test-bad "./test-bad.sh")
   #+end_src
6) run 500 iterations -- note that =asm-gp-pack= must be in your path
   #+begin_src clojure
     (run-experiment
      (dorun
       (map  (fn [run]
               (do
                 (evolve baseline)
                 (let [save-dir (str "variants/" (.toString run))]
                   (s/sh "mkdir" save-dir)
                   (s/sh "asm-gp-pack" save-dir)
                   (write-obj fitness-cache-path @fitness-cache))))
             (range 500))))
   #+end_src

** gp operations in other languages
*** Haskell
**** script
    :PROPERTIES:
    :tangle:   test/gp-op-haskell
    :END:
Going to try to split this up into multiple independent runs through a
clojure script, because for some reason zsh kept insisting on killing
off the single large monolithic run.

tangled to the =test/gp-op.clj= script which can be run using
#+begin_src sh :tangle no
  java -cp ../../../src/clojure/clojure.jar:../../../src/clojure-contrib/clojure-contrib.jar clojure.main ../test/gp-op-haskell.clj
#+end_src

#+begin_src clojure :session asm-gp
  (load-file "../src/asm-gp.clj")(in-ns 'asm-gp)
  (def target-fitness 10)
  (def good-mult 1)
  (def bad-mult 5)
  (def compiler "ghc")
  (def baseline-path "gcd.s")
  (def good-path-path "good.path")
  (def bad-path-path "bad.path")
  (def test-dir "~/research/code/gcd_h/")
  (def test-good "./test-good.sh")
  (def test-bad "./test-bad.sh")
  (def fitness-cache-path
        (.getPath (f/file-str "~/research/code/gcd_h/fitness-cache.clj")))
  (def section-size (try (Integer/parseInt (second *command-line-args*))
                         (catch Exception e 1)))
  
  (message "running experiment")
  (run-experiment
   (dorun
    (map
     (fn [op]
       (message "%s %d" (name op) section-size)
       (write-obj
        (format "./gp-operations/%s.%d.results"
                (name op) section-size)
        (pmap #(let [new (cond
                          (= op 'swap-asm)
                          (swap-asm baseline section-size)
                          (= op 'delete-asm)
                          (delete-asm baseline section-size)
                          (= op 'append-asm)
                          (append-asm baseline section-size))]
                 {:run %
                  :individual new
                  :fitness (evaluate-asm new)})
              (range 1000))))
     '(swap-asm delete-asm append-asm))))
#+end_src

*** java
|                      | append | delete | swap |
|----------------------+--------+--------+------|
| total fitness        |    662 |      0 |   56 |
| fitness = 5          |    129 |      0 |    6 |

**** java-gp-op script
    :PROPERTIES:
    :tangle:   test/java-gp-op
    :END:
tangled to the =test/java-gp-op.clj= script which can be run using
#+begin_src sh :tangle no
  java -cp ../../../src/clojure/clojure.jar:../../../src/clojure-contrib/clojure-contrib.jar:../lib/bcel-5.3-SNAPSHOT.jar clojure.main ../test/java-gp-op.clj
#+end_src

#+begin_src clojure :session asm-gp
  (load-file "../src/asm-gp.clj")
  (load-file "../src/bytecode-gp.clj")
  (in-ns 'asm-gp)
  (def target-fitness 10)
  (def max-generations 10)
  (def population-size 40)
  (def use-tournament false)
  (def good-mult 1)
  (def bad-mult 5)
  (def gcc-flags nil)
  (def baseline-path "gcd.class")
  (def fitness-cache-path
       (.getPath (f/file-str "~/research/code/gcd_java/fitness-cache.clj")))
  (def good-path-path nil)
  (def bad-path-path nil)
  (def test-dir "~/research/code/gcd_java/")
  (def test-good "./my-test-good.sh")
  (def test-bad "./my-test-bad.sh")
  (def section-size
       (try (Integer/parseInt (first *command-line-args*))
            (catch Exception e 1)))
  (def base-class (.parse (new ClassParser "gcd.class")))
  
  (message "running experiment")
  (run-experiment
   (dorun
    (map
     (fn [op]
       (message "%s %d" (name op) section-size)
       (write-obj
        (format "./gp-operations/%s.%d.results"
                (name op) section-size)
        (pmap #(let [new (cond
                          (= op 'swap-asm)
                          (swap-asm baseline section-size)
                          (= op 'delete-asm)
                          (delete-asm baseline section-size)
                          (= op 'append-asm)
                          (append-asm baseline section-size))]
                 (message "\t%d" %)
                 {:run %
                  :individual (let [handles (seq (.getInstructionHandles new))]
                                (if (empty? handles)
                                  "failed-mutation"
                                  (map (fn [byte-code]
                                         (.getName (.getInstruction byte-code)))
                                       handles)))
                  :fitness (evaluate-asm new)
                  :compile (if (> (evaluate-asm new) 0)
                             true
                             (if (compile-asm new) true false))})
              (range 1000))))
     '(append-asm swap-asm delete-asm))))
#+end_src

** gcd in Java -- Java Byte Code
*** method
    :PROPERTIES:
    :tangle:   test/gcd_java
    :results:  silent
    :END:

The following steps are tangled to the =test/java-gcd.clj= script
which can be run from inside of the =gcd_java= directory using
#+begin_src sh :tangle no
  java -cp ../../../src/clojure/clojure.jar:../../../src/clojure-contrib/clojure-contrib.jar:../lib/bcel-5.3-SNAPSHOT.jar:../src clojure.main ../test/java-gcd.clj
#+end_src

1) create the =gcd.class= file and copy =asm-gp.clj= into the classpath
   #+begin_src sh :tangle no
     cd gcd_java
     javac gcd.java
     cp ../src/asm-gp.clj ../src/asm_gp.clj 
   #+end_src
2) start a slime repl in the =gcd_java/= directory
3) load up our framework (including some over-defined functions for
   working with Java =.class= Byte-code files) and step into the
   namespace
   #+begin_src clojure
     (load-file "../src/asm-gp.clj")
     (load-file "../src/bytecode-gp.clj")
     (in-ns 'asm-gp)
   #+end_src
4) define a =base-class= needed by the new bytecode stuff
   #+begin_src clojure
     (def base-class (.parse (new ClassParser "gcd.class")))
   #+end_src
5) set the GP parameters
   #+begin_src clojure
     (def target-fitness 10)
     (def max-generations 20)
     (def population-size 400)
     (def use-tournament false)
     (def max-section-size 1)
     (def good-mult 1)
     (def bad-mult 5)
     (def gcc-flags nil)
     (def baseline-path "gcd.class")
     (def fitness-cache-path
          (.getPath (f/file-str "~/research/exp/gcd_java/fitness-cache.clj")))
     (def good-path-path nil)
     (def bad-path-path nil)
     (def test-timeout 4000)
     (def test-dir "~/research/code/gcd_java/")
     (def test-good "./my-test-good.sh")
     (def test-bad "./my-test-bad.sh")
   #+end_src
6) run 500 iterations -- note that =asm-gp-pack= must be in your path
   #+begin_src clojure
     (run-experiment
      (dorun
       (map  (fn [run]
               (do
                 (evolve baseline)
                 (let [save-dir (str "variants/" (.toString run))]
                   (s/sh "mkdir" save-dir)
                   (s/sh "asm-gp-pack" save-dir))))
             (range 500))))
   #+end_src
** gcd in Haskell
   :PROPERTIES:
   :blog:     t
   :type:     experiment
   :END:
This will attempt to recreate and repair the gcd bug in Haskell.

Here's a working gcd taken from the Haskell Prelude.hs
#+begin_src haskell
  gcd      :: (Integral a) => a -> a -> a
  gcd 0 0  =  error "Prelude.gcd: gcd 0 0 is undefined"
  gcd x y  =  gcd' (abs x) (abs y)
              where gcd' x 0  =  x
                    gcd' x y  =  gcd' y (x `rem` y)
#+end_src

Here's a buggy version of the above -- writing a buggy Haskell program
might be the hardest part of this exercise...
#+begin_src haskell :tangle gcd_h/gcd
  import System
  
  main :: IO ()
  main = do
    args <- getArgs
    buggy_gcd (read (args!!0)::Int) (read (args!!1)::Int)
        where
          buggy_gcd     :: (Integral a) => a -> a -> IO()
          buggy_gcd a b =  if (a == 0) then
                               do
                                 print b
                                 buggy_gcd' a b
                           else
                               buggy_gcd' a b
              where
                buggy_gcd' a b = if (b == 0) then
                                     print a
                                 else
                                     if (a > b) then
                                         buggy_gcd' (a - b) b
                                     else
                                         buggy_gcd' a (b - a)
#+end_src

*** results
The largely unaltered method (the only code change involved adding a
compiler option so that =ghc= could be used instead of =gcc=) found
repairs in 15/500 runs.  Although the generated Haskell ASM looked
much uglier than the C asm, and was much longer (885 lines instead of
22 lines) 15/500 is a better success rate than the 2/500 repair rate
with ASM generated from C code.

For what it's worth some of the repair diffs are included here.
#+begin_src diff
  686d685
  <       leal -28(%edi),%eax
#+end_src
#+begin_src diff
  672c672
  < .LcR0:
  ---
  >       movl 4(%ebp),%eax
  677c677
  <       movl 4(%ebp),%eax
  ---
  > .LcR0:
#+end_src
#+begin_src diff
  475a476
  >       movl %eax,-4(%ebp)
#+end_src
#+begin_src diff
  263a264
  >       movl $stg_CAF_BLACKHOLE_info,-4(%edi)
#+end_src

Of the 15 solutions 7 were unique with two appearing 2 times one
appearing 3 times and one appearing 5 times

Starting points of the 15 diffs
| 263a264 |
| 475a476 |
| 598c598 |
| 648a649 |
| 648a649 |
| 672c672 |
| 672c672 |
| 672c672 |
| 686d685 |
| 686d685 |
| 686d685 |
| 686d685 |
| 686d685 |
| 687d686 |
| 687d686 |

: 214000 fitness evaluations
across all 500 runs

*** method
    :PROPERTIES:
    :tangle:   test/gcd_h
    :results:  silent
    :session:  asm-gp
    :END:

The following steps are tangled to the =test/gcd.clj= script which can
be run from inside of the =gcd_h= directory using
#+begin_src sh :tangle no
  java -cp ../../../src/clojure/clojure.jar:../../../src/clojure-contrib/clojure-contrib.jar clojure.main ../test/gcd_h.clj
#+end_src

1) create the =gcd.s= file
   #+begin_src sh :tangle no
     cd gcd
     ghc -S gcd.hs
   #+end_src
2) start a slime repl in the =gcd/= directory
3) load the resulting file and step into the namespace
   #+begin_src clojure
     (load-file "../src/asm-gp.clj")(in-ns 'asm-gp)
   #+end_src
4) set the GP parameters
   #+begin_src clojure
     (def target-fitness 10)
     (def max-generations 20)
     (def population-size 400)
     (def use-tournament false)
     (def max-section-size 1)
     (def fitness-cache-path
          (.getPath (f/file-str "~/research/exp/gcd_h/fitness-cache.clj")))
     (def good-mult 1)
     (def bad-mult 5)
     (def compiler "ghc")
     (def compiler-flags nil)
     (def baseline-path "gcd.s")
     (def good-path-path "good.path")
     (def bad-path-path "bad.path")
     (def test-timeout 2000)
     (def test-dir "~/research/code/gcd_h/")
     (def test-good "./test-good.sh")
     (def test-bad "./test-bad.sh")
   #+end_src
5) run 500 iterations -- note that =asm-gp-pack= must be in your path
   #+begin_src clojure
     (run-experiment
      (dorun
       (map  (fn [run]
               (do
                 (evolve baseline)
                 (let [save-dir (str "variants/" (.toString run))]
                   (s/sh "mkdir" save-dir)
                   (s/sh "asm-gp-pack" save-dir))))
             (range 500))))
   #+end_src

** gcd
   :PROPERTIES:
   :blog:     t
   :type:     experiment
   :END:
Now that the asm codebase has been brought into line with the existing
genprog methodology we should be able to directly inspect the effects
of changing the representation from a C AST to a linear string of ASM
commands.

The only difference between this new setup and the traditional genprog
implementation aside from representation is the construction of our
bad and good paths -- which is very representation dependent.

*** results
- Using Stochastic Universal Sampling and allowing GP operations to
  operation on only on single lines of code, with a population of 40
  and a max of 10 generations.  2/500 runs found a solution, resulting
  in the following two solutions
  #+begin_src diff
    20c20
    <       addq    $8, %rax
    ---
    >       addq    $16, %rax
    28c28
    <       addq    $16, %rax
    ---
    >       addq    $8, %rax
  #+end_src
  #+begin_src diff
    26c26
    <       movsd   %xmm0, -8(%rbp)
    ---
    >       movsd   %xmm0, -16(%rbp)
    34c34
    <       movsd   %xmm0, -16(%rbp)
    ---
    >       movsd   %xmm0, -8(%rbp)
  #+end_src

- Using the same parameters as above but allowing GP operations to
  operate on sections of code between 1-3 lines in length resulted in
  6/500 runs finding a solution, most solutions found were similar to
  the following
  #+begin_src diff
    42a43,44
    >       movsd   %xmm0, -8(%rbp)
    >       jmp     .L4
  #+end_src

The following results were generated using larger populations than the
genprog standard.

- using Stochastic Universal Sampling and allowing GP operations to
  operate on sections of code between 1-3 commands in length, with a
  population of 400 and a maximum of 10 generations. 75/500 runs
  succeeded.  Some interesting new solutions looking like
  #+begin_src diff
    40a41,42
    >       movsd   %xmm0, -8(%rbp)
    >       jmp     .L4
  #+end_src
  #+begin_src diff
    43a44,45
    >       leave
    >       ret
  #+end_src
  #+begin_src diff
    43a44,46
    >       movl    $0, %eax
    >       leave
    >       ret
  #+end_src
  #+begin_src diff
    20c20
    <       addq    $8, %rax
    ---
    >       addq    $16, %rax
    28c28
    <       addq    $16, %rax
    ---
    >       addq    $8, %rax
  #+end_src
  and
  #+begin_src diff
    26c26
    <       movsd   %xmm0, -8(%rbp)
    ---
    >       movsd   %xmm0, -16(%rbp)
    34c34
    <       movsd   %xmm0, -16(%rbp)
    ---
    >       movsd   %xmm0, -8(%rbp)    
  #+end_src
  only one of which looks like something that a person would generate
  by hand.
  
**** intermediate results
The following results are from intermediate runs while small
configuration and development issues were still being resolved.

***** configuration issues
- now using SUS running on pinyon, getting some solutions, but not as
  well (at least within 10 generations) as the normal genprog.  The
  most recent test resulted in 4/500 10 generation runs succeeding.
  Some solutions include
  #+begin_src diff
    26c26
    <       movsd   %xmm0, -8(%rbp)
    ---
    >       movsd   %xmm0, -16(%rbp)
    34c34
    <       movsd   %xmm0, -16(%rbp)
    ---
    >       movsd   %xmm0, -8(%rbp)
  #+end_src
  and
  #+begin_src diff
    20c20
    <       addq    $8, %rax
    ---
    >       addq    $16, %rax
    28c28
    <       addq    $16, %rax
    ---
    >       addq    $8, %rax
  #+end_src
- fixed tournament with size of 2 -- which is way too small
  - tournament generational selection meaning that when a new
    generation is built from the previous every individual in the new
    generation is selected using a tournament.  0/100 trials found a
    repair
  - tournament selection of individuals to undergo mutation, but
    elitist methods for selection when moving from one population to
    the next -- also 0/100
***** broken tournament
all of the following results should be ignored as they used a broken tournament
- *broken tournament* In the first run, with exactly genprog's GP
  parameters and operations, and with single-line GP operators only
  1/100 trials succeeded.  That one did have a surprising solution.
  #+begin_src diff
    26c26
    <       movsd   %xmm0, -8(%rbp)
    ---
    >       movsd   %xmm0, -16(%rbp)
    34c34
    <       movsd   %xmm0, -16(%rbp)
    ---
    >       movsd   %xmm0, -8(%rbp)
  #+end_src
- *broken tournament* I'm going to try a run with double the
  population size, just to see the results, again similar results,
  just 1/100, and actually found the same fix
- *broken tournament* then I'll change from single-line mutation
  operators to up-to-3 line mutations.  I ran this twice operating on
  sections of size 1-3
  - 0/100 success
  - 1/100 success with the following solution
    #+begin_src diff
      41a42,43
      >       leave
      >       ret
    #+end_src
    
*** method
    :PROPERTIES:
    :tangle:   test/gcd
    :results:  silent
    :session:  asm-gp
    :END:

The following steps are tangled to the =test/gcd.clj= script which can
be run from inside of the =gcd= directory using
#+begin_src sh :tangle no
  java -cp ../../../src/clojure/clojure.jar:../../../src/clojure-contrib/clojure-contrib.jar clojure.main ../test/gcd.clj
#+end_src

1) create the =gcd.s= file
   #+begin_src sh :tangle no
     cd gcd
     gcc -S gcd.c
   #+end_src
2) start a slime repl in the =gcd/= directory
3) load the resulting file and step into the namespace
   #+begin_src clojure
     (load-file "../src/asm-gp.clj")(in-ns 'asm-gp)
   #+end_src
4) set the GP parameters
   #+begin_src clojure
     (def target-fitness 10)
     (def max-generations 20)
     (def population-size 400)
     (def use-tournament false)
     (def max-section-size 1)
     (def good-mult 1)
     (def bad-mult 5)
     (def compiler "gcc")
     (def compiler-flags nil)
     (def baseline-path "gcd.s")
     (def good-path-path "good.path")
     (def bad-path-path "bad.path")
     (def test-timeout 2000)
     (def fitness-cache-path
          (.getPath (f/file-str "~/research/exp/gcd/fitness-cache.clj")))
     (def test-dir "~/research/code/gcd/")
     (def test-good "./test-good.sh")
     (def test-bad "./test-bad.sh")
   #+end_src
5) run 500 iterations -- note that =asm-gp-pack= must be in your path
   #+begin_src clojure
     (run-experiment
      (dorun
       (map  (fn [run]
               (do
                 (evolve baseline)
                 (let [save-dir (str "variants/" (.toString run))]
                   (s/sh "mkdir" save-dir)
                   (s/sh "asm-gp-pack" save-dir))))
             (range 500))))
   #+end_src

** nullhttpd
   :PROPERTIES:
   :tangle:   test/nullhttpd
   :blog:     t
   :type:     experiment
   :END:
: gcc -pthread -S httpd_comb.c
: cat httpd_comb.s |wc
:   6933   18245  127541

The nullhttpd assembly file is almost 7000 lines long.  I take the
ability of the ASM-GP to find a repair against this large real-life
bug as a good indicator for the potential viability of an ASM
representation.

*** results
9/500 runs found a successful repair with the following parameters
#+begin_src clojure
  (def target-fitness 10)
  (def max-generations 20)
  (def population-size 40)
  (def use-tournament false)
  (def max-section-size 1)
  (def good-mult 1)
  (def bad-mult 5)
  (def good-path-path "good.path")
  (def bad-path-path "bad.path")
  ;; let nullhttpd use it's own fitness cache
  (def fitness-cache-path
       (.getPath (f/file-str "~/research/nullhttpd/fitness-cache.clj")))
  (def baseline-path "httpd_comb.s")
  (def gcc-flags (list "-pthread"))
  (def test-dir "~/research/nullhttpd/")
  (def test-good "./my-good-test.sh")
  (def test-bad "./my-bad-test.sh")
#+end_src

There was a wide variety of repairs with 7 unique repairs one of which
was found 3 times.
#+begin_src diff
  3719d3718
  <       movl    $1024, 8(%esp)
#+end_src
Some of the other repairs are listed here, although they don't really
mean anything to me.
#+begin_src diff
  2637c2637
  <       addl    $2624, %eax
  ---
  >       movl    -2200(%ebp), %eax
  4203c4203
  <       movl    -2200(%ebp), %eax
  ---
  >       addl    $2624, %eax
#+end_src
#+begin_src diff
  3642c3642
  < ReadPOSTData:
  ---
  >       jmp     .L404
  6443c6443
  <       jmp     .L404
  ---
  > ReadPOSTData:
#+end_src
#+begin_src diff
  2011c2011
  <       call    strncpy
  ---
  >       movl    $.LC3, 4(%esp)
  4172c4172
  <       movl    $.LC3, 4(%esp)
  ---
  >       call    strncpy
#+end_src
#+begin_src diff
  4078a4079
  >       addl    12(%ebp), %eax
#+end_src

**** Sorting out validity of solutions
Although only 9 of the 500 runs found a real repair 15 of the 500 runs
reportedly an individual as a successful repair.  I believe that these
6 fake repairs were due to evolved variants which managed to /trick/
the good or bad test scripts into returning success.  For example
earlier runs of nullhttpd resulted in variants which would remove the
index.html file resulting in successful completion of the bad test
case even though the nullhttpd-exploit hadn't been defeated.

The following table lists the 15 reported solutions and which ones
after manual inspection did actually defeat the nullhttpd exploit.
| run | survives nullhttpd-exploit |
|-----+----------------------------|
|   5 | yes                        |
|  58 | yes                        |
|  64 | yes                        |
|  67 | no                         |
|  75 | yes                        |
|  84 | no                         |
|  97 | yes                        |
| 164 | yes                        |
| 255 | no                         |
| 267 | no                         |
| 337 | no                         |
| 356 | yes                        |
| 363 | yes                        |
| 457 | no                         |
| 497 | yes                        |

A variety of different solutions were found, the starting point of the
9 successful patches were
| 2011c2011 |
| 2637c2637 |
| 3642c3642 |
| 3674c3674 |
| 3719d3718 |
| 3719d3718 |
| 3719d3718 |
| 4078a4079 |
| 4212d4211 |

*** method
run the following from inside of =~/research/nullhttpd/=, note that
the default java stack size had to be increased
#+begin_src sh :tangle no
  java -Xss2m -cp ../../src/clojure/clojure.jar:../../src/clojure-contrib/clojure-contrib.jar clojure.main ../code/test/nullhttpd.clj
#+end_src

1) create the =http_comp.s= file
   #+begin_src sh :tangle no
     cd ~/research/nullhttpd/
     gcc -S httpd_comb.c
   #+end_src
2) start up a slime repl in the nullhttpd directory
3) load up asm-gp
   #+begin_src clojure
     (load-file "../code/src/asm-gp.clj")(in-ns 'asm-gp)
   #+end_src
4) set the GP parameters
   #+begin_src clojure
     (def target-fitness 10)
     (def max-generations 20)
     (def population-size 40)
     (def use-tournament false)
     (def max-section-size 1)
     (def good-mult 1)
     (def bad-mult 5)
     (def good-path-path "good.path")
     (def bad-path-path "bad.path")
     ;; let nullhttpd use it's own fitness cache
     (def fitness-cache-path
          (.getPath (f/file-str "~/research/nullhttpd/fitness-cache.clj")))
     (def baseline-path "httpd_comb.s")
     (def gcc-flags (list "-pthread"))
     (def test-dir "~/research/nullhttpd/")
     (def test-good "./my-good-test.sh")
     (def test-bad "./my-bad-test.sh")
   #+end_src
5) actually perform 500 runs using the =run-experiment= macro to
   handle setup and cleanup
   #+begin_src clojure
     (run-experiment
      (dorun
       (map  (fn [run]
               (message "run %d" run)
               (evolve baseline)
               (let [save-dir (str "variants/" (.toString run))]
                 (s/sh "mkdir" save-dir)
                 (s/sh "asm-gp-pack" save-dir)))
             (range 500))))
   #+end_src

*** good and bad paths
need to generate (see [[general-path-generation]])

*** new test files
    :PROPERTIES:
    :tangle:   no
    :END:
saving the next port number in "last-port", and calling =test-good.sh=
and =test-bad.sh= so that no changes need be made on the clojure side
of things.

#+begin_src sh
  #!/bin/sh
  
  # read and increment last-port then write it back out
  n=`cat last-port`
  if [ $n != 8999 ]; then
      n=`expr $n + 1`
  else
      n="2000"
  fi
  echo $n > last-port
  
  # file
  outfile="output-$n"
  execfile="exec-$n"
  
  # run the test
  rm -f $outfile
  touch $outfile
  cp $1 $execfile
  ./test-good.sh $execfile $outfile $n 2&> /dev/null
  cat $outfile
  rm $outfile
  rm $execfile
  rm -rf "$execfile-g"
#+end_src
** gp operations over real programs
   :PROPERTIES:
   :tangle:   collector
   :END:

just looking at compilation by program, operation, section-size

|            | gcd | sendmail | deroff | nullhttpd | flex |
|------------+-----+----------+--------+-----------+------|
| append-asm | 848 |      839 |    850 |       900 |   -1 |
| delete-asm | 896 |      892 |    870 |       916 |   -1 |
| swap-asm   | 913 |      962 |    964 |       981 |   -1 |

#+begin_src clojure
  (load-file "../src/asm-gp.clj")(in-ns 'asm-gp)
  
  (write-obj "compilations.clj"
             (map
              (fn [op]
                (apply list op
                       (map
                        #(try
                          (.size (filter :compile (read-obj (format "results/%s.%s.1.clj" % op))))
                          (catch Exception e -1))
                        '("gcd" "s4" "deroff" "nullhttpd" "flex"))))
              '("append-asm" "delete-asm" "swap-asm")))
#+end_src

#+begin_src clojure :tangle no
  (load-file "../src/asm-gp.clj")(in-ns 'asm-gp)
  
  (println (.size (filter :compile (read-obj (second *command-line-args*)))))
#+end_src

#+begin_src clojure :session asm-gp
  comps
#+end_src

#+results:

*** script
    :PROPERTIES:
    :tangle:   test/operations
    :END:
Going to try to split this up into multiple independent runs through a
clojure script, because for some reason zsh kept insisting on killing
off the single large monolithic run.

tangled to the =test/operations.clj= script which can be run using
#+begin_src sh :tangle no
  java -Xss256m -Xmx256m -cp ../../../src/clojure/clojure.jar:../../../src/clojure-contrib/clojure-contrib.jar clojure.main ../test/operations.clj 1
#+end_src

#+begin_src clojure :session asm-gp
  (load-file "../src/asm-gp.clj")(in-ns 'asm-gp)
  (def section-size (try (Integer/parseInt (second *command-line-args*))
                         (catch Exception e 1)))
  
  (doseq [group '(("gcd" "gcd.s" false)
                  ("deroff" "deroff.s" false)
                  ("s4" "s4.s" false)
                  ("nullhttpd" "null.s" true)
                  ("flex" "flex.s" false))]
    (let [call-me-by (nth group 0)
          path (nth group 1)
          flags (nth group 2)]
      (def baseline (read-asm path))
      (if flags
        (def compiler-flags (list "-pthread"))
        (def compiler-flags nil))
      ;; sanity
      (when (not (compile-asm baseline))
        (throw (message "%s can't compile at baseline" path)))
      (doseq [op '(swap-asm delete-asm append-asm)]
        (message "%s %s %d" path (name op) section-size)
        (write-obj
         (format "./results/%s.%s.%d.clj"
                 call-me-by (name op) section-size)
         (map #(let [new (cond
                          (= op 'swap-asm)
                          (swap-asm baseline section-size)
                          (= op 'delete-asm)
                          (delete-asm baseline section-size)
                          (= op 'append-asm)
                          (append-asm baseline section-size))]
                 {:run %
                  :individual new
                  :compile (compile-asm new)})
              (range 1000))))))
#+end_src

** gp operations
   :PROPERTIES:
   :blog:     t
   :type:     experiment
   :END:
Investigating the effectiveness of the GP operations over assembly
files.

*** results
The following table show the results of applying each of the three GP
operations run with single-line asm blocks to the baseline =gcs.s=
individual 1000 times.
|                           |    append |    delete |       swap |
|---------------------------+-----------+-----------+------------|
| compiled                  |       921 |       926 |        993 |
| total fitness             |      3049 |      1173 |        655 |
| fitness=5                 |       598 |       226 |        115 |
| ave fitness of compilable | 3.3105320 | 1.1812689 | 0.70734341 |
#+TBLFM: $3=@3/@2::$4=@3/@2::@5$2=@3/@2

As shown nearly all of the variants were successfully compilable,
however many did have a worse fitness score than the baseline
individual which had a fitness of 5.

*** effects of section-size
Increasing to two and three command blocks, so for example delete
removes two lines from the asm file and swap swaps two two-line
portions etc... yields the following results
|               | append1 | append2 | append3 | delete | delete2 | delete3 | swap | swap2 | swap3 |
|---------------+---------+---------+---------+--------+---------+---------+------+-------+-------|
| compiled      |     921 |     837 |     769 |    993 |     819 | 749     |  926 |   996 | 995   |
| total fitness |    3049 |    1902 |    1531 |   1173 |     526 | 465     |  655 |   544 | 456   |
| fitness=5     |     598 |     366 |     300 |    226 |      94 | 85      |  115 |    93 | 79    |

The only real surprise here is that in terms of compilation swaping
large sections of code seems to be *much* less disruptive than
appending or deletion -- which I suppose makes sense if the absolute
number of commands has some direct effect on compilability.  Notice
however that despite many more of the swapped variants compiling the
fitness of the append variants is higher.

*** script
    :PROPERTIES:
    :tangle:   test/gp-op
    :END:
Going to try to split this up into multiple independent runs through a
clojure script, because for some reason zsh kept insisting on killing
off the single large monolithic run.

tangled to the =test/gp-op.clj= script which can be run using
#+begin_src sh :tangle no
  java -cp ../../../src/clojure/clojure.jar:../../../src/clojure-contrib/clojure-contrib.jar clojure.main ../test/gp-op.clj
#+end_src

#+begin_src clojure :session asm-gp
  (load-file "../src/asm-gp.clj")(in-ns 'asm-gp)
  (def target-fitness 10)
  (def good-mult 1)
  (def bad-mult 5)
  (def gcc-flags nil)
  (def baseline-path "gcd.s")
  (def good-path-path "good.path")
  (def bad-path-path "bad.path")
  (def test-dir "~/research/code/gcd/")
  (def test-good "./test-good.sh")
  (def test-bad "./test-bad.sh")
  (def section-size (Integer/parseInt (second *command-line-args*)))
  
  (message "running experiment")
  (run-experiment
   (dorun
    (map
     (fn [op]
       (message "%s %d" (name op) section-size)
       (write-obj
        (format "./gp-operations/%s.%d.results"
                (name op) section-size)
        (pmap #(let [new (cond
                          (= op 'swap-asm)
                          (swap-asm baseline section-size)
                          (= op 'delete-asm)
                          (delete-asm baseline section-size)
                          (= op 'append-asm)
                          (append-asm baseline section-size))]
                 {:run %
                  :individual new
                  :fitness (evaluate-asm new)})
              (range 1000))))
     '(swap-asm delete-asm append-asm))))
#+end_src

** Old GP experiment
Everything below here is leftover from the initial buggier
implementation of these operators.

*** functions
    :PROPERTIES:
    :tangle:   no
    :END:
for each operation, run it 1000 times and see the results of each run.
each run should return a hash of the following form
- individual :: the modified individual
- compile :: true or false
- fitness :: numerical fitness

**** baseline
#+begin_src clojure
  (defn gp-op-test
    "Test the given GP operation (OP) N times against BASELINE, return a hash
  of the resulting individuals."
    [op n baseline]
    (let [run-test
          (fn [bin test mult]
            (* mult
               (.size
                (remove #(or (= "" %) (= "Killed" %))
                        (seq (.split
                              (s/sh test bin
                                    :dir (f/file-str test-dir)) "\n"))))))]
      (pmap #(let [new (op baseline)
                   bin (compile-asm new)]
               {:run %
                :individual new
                :compile (if bin true false)
                :fitness (if bin ;; only run the test if it compiled
                           (+ (run-test bin test-good good-mult)
                              (run-test bin test-bad bad-mult))
                           0)})
            (range n))))
#+end_src

**** better
and with the [[better-gp-op]] function
#+begin_src clojure
  (defn better-gp-op-test
    "Test the given GP operation (OP) N times against BASELINE, return a
  hash of the resulting individuals.  Use the better-gp-op using MODEL
  for similarity and running each tournament out of M individuals."
    [op n baseline m model]
    (let [run-test
          (fn [bin test mult]
            (* mult
               (.size
                (remove #(or (= "" %) (= "Killed" %))
                        (seq (.split
                              (s/sh test bin
                                    :dir (f/file-str test-dir)) "\n"))))))]
      (pmap #(let [new (better-gp-op op baseline model m)
                   bin (compile-asm new)]
               {:run %
                :individual new
                :compile (if bin true false)
                :fitness (if bin ;; only run the test if it compiled
                           (+ (run-test bin test-good good-mult)
                              (run-test bin test-bad bad-mult))
                           0)})
            (range n))))
#+end_src
*** method
**** baseline
     :PROPERTIES:
     :tangle:   test/gp-operations
     :results:  silent
     :session:  asm-gp
     :END:
The following steps are tangled to the =test-gp-operations.clj= script
which can be run using
#+begin_src sh :tangle no
  java -cp ../../../src/clojure/clojure.jar:../../../src/clojure-contrib/clojure-contrib.jar clojure.main ../test/gp-operations.clj
#+end_src

1) create the =gcd.s= file
   #+begin_src sh :results silent :tangle no
     gcc -S gcd.c
   #+end_src
2) load the resulting file and step into the namespace
   #+begin_src clojure :session asm-gp
     (load-file "../src/asm-gp.clj")(in-ns 'asm-gp)
   #+end_src
3) set the GP parameters
   #+begin_src clojure
     (def tournament-size 2)
     (def good-mult 1)
     (def bad-mult 5)
     (def gcc-flags nil)
     (def test-dir "~/research/code/gcd/")
     (def test-good "./test-good.sh")
     (def test-bad "./test-bad.sh")
   #+end_src
4) function to run the test
   #+begin_src clojure
     (defn gp-op-test
       "Test the given GP operation (OP) N times against BASELINE, return a hash
     of the resulting individuals."
       [op n m baseline]
       (let [run-test
             (fn [bin test mult]
               (* mult
                  (.size
                   (remove #(or (= "" %) (= "Killed" %))
                           (seq (.split
                                 (s/sh test bin
                                       :dir (f/file-str test-dir)) "\n"))))))]
         (pmap #(let [new (op baseline m)
                      bin (compile-asm new)]
                  {:run %
                   :individual new
                   :compile (if bin true false)
                   :fitness (if bin ;; only run the test if it compiled
                              (+ (run-test bin test-good good-mult)
                                 (run-test bin test-bad bad-mult))
                              0)})
               (range n))))
   #+end_src
5) run each operation 1000 times saving the results to a file
   #+begin_src clojure
     (run-experiment
      (dorun
       (map
        (fn [max]
          (message "swap %d" max)
          (write-obj (format "./gp-operations/swap.%d.results" max-section-size)
                     (gp-op-test swap-asm 1000 max baseline))
          (message "delete %d" max)
          (write-obj (format "./gp-operations/delete.%d.results" max-section-size)
                     (gp-op-test delete-asm 1000 max baseline))
          (message "append %d" max)
          (write-obj (format "./gp-operations/append.%d.results" max-section-size)
                     (gp-op-test append-asm 1000 max baseline)))
        (range 6))))
   #+end_src

**** better
     :PROPERTIES:
     :tangle:   test/better-gp-operations
     :results:  silent
     :session:  asm-gp
     :END:
The following steps are tangled to the =test-gp-operations.clj= script
which can be run using
#+begin_src sh :tangle no
  java -cp ../../src/clojure/clojure.jar:../../src/clojure-contrib/clojure-contrib.jar clojure.main test/better-gp-operations.clj
#+end_src

1) create the =gcd.s= file
   #+begin_src sh :results silent :tangle no
     gcc -S gcd.c
   #+end_src
2) load the resulting file and step into the namespace
   #+begin_src clojure :session asm-gp
     (load-file "src/asm-gp.clj")(in-ns 'asm-gp)
   #+end_src
3) load up the baseline individual
   #+begin_src clojure
     (def baseline (read-asm (f/file-str "~/research/code/gcd.s")))
   #+end_src
4) load up the model of command patterns
   #+begin_src clojure
     (def model (read-obj "data/c-sample-model"))
   #+end_src
5) run each operation 1000 times saving the results to a file
   #+begin_src clojure
     (println "mut")
     (write-obj "./gp-operations/mut.normalized.results"
                (better-gp-op-test mut-asm 1000 baseline 10 model))
     (println "swp")
     (write-obj "./gp-operations/swp.normalized.results"
                (better-gp-op-test swp-asm 1000 baseline 10 model))
     (println "del")
     (write-obj "./gp-operations/del.normalized.results"
                (better-gp-op-test del-asm 1000 baseline 10 model))
     (println "inj")
     (write-obj "./gp-operations/inj.normalized.results"
                (better-gp-op-test inj-asm 1000 baseline 10 model))
   #+end_src

*** results
note that the following were run on early versions of this code base.
**** diffs
#+begin_src clojure :session asm-gp
  (write-asm "/tmp/new" (del-asm baseline))
#+end_src

#+begin_src sh
  diff /tmp/new gcd.s
#+end_src

**** single line GP ops
     :PROPERTIES:
     :CUSTOM_ID: single-line-gp-ops
     :END:
*NOTE*: all of this data is based on the *single line* versions of the
GP operations

after 1000 runs of each GP operation
|     | successful compile | total fitness | graph fitness                |
|-----+--------------------+---------------+------------------------------|
| mut |                 48 |           165 | [[file:data/mut-single-fit.png]] |
| inj |                837 |          3160 | [[file:data/inj-single-fit.png]] |
| swp |                898 |          1032 | [[file:data/swp-single-fit.png]] |
| del |                899 |          1977 | [[file:data/del-single-fit.png]] |

This data is saved in =gp-operations= and can be loaded with lines
like
#+begin_src clojure :tangle no
  (def mut (read-obj "./gp-operations/mut.results"))
#+end_src

**** section base GP
     :PROPERTIES:
     :CUSTOM_ID: section-based-gp-ops
     :END:
after 1000 runs of each GP operation
|     | successful compile | total fitness | graph fitness |
|-----+--------------------+---------------+---------------|
| mut |                102 |           285 |               |
| inj |                373 |          1144 |               |
| swp |                202 |           193 |               |
| del |                500 |           695 |               |

**** "better" GP ops
     :PROPERTIES:
     :CUSTOM_ID: better-gp-ops
     :END:
GP ops run with the [[better-gp-op]] pattern profiling command.
after 1000 runs of each GP operation
|     | successful compile | total fitness | graph fitness                |
|-----+--------------------+---------------+------------------------------|
| mut |                176 |           860 | [[file:data/mut-better-fit.png]] |
| inj |                112 |           183 | [[file:data/inj-better-fit.png]] |
| swp |                103 |            88 | [[file:data/swp-better-fit.png]] |
| del |                871 |          2717 | [[file:data/del-better-fit.png]] |

so it's possible that these changes could also be the result of
running on a different machine, or running on a slightly later version
of the code.

**** normalized likely GP ops
     :PROPERTIES:
     :CUSTOM_ID: normalized-gp-ops
     :END:
after 1000 runs of each GP operation
|     | successful compile | total fitness | graph fitness |
|-----+--------------------+---------------+---------------|
| mut |                 48 |          1020 |               |
| inj |                 84 |           174 |               |
| swp |                 87 |           104 |               |
| del |                291 |           164 |               |

This data is saved in =gp-operations= and can be loaded with lines
like
This data is saved in =gp-operations= and can be loaded and inspected
with lines like...
#+begin_src clojure :tangle no
  (def mut (read-obj "./gp-operations/mut.normalized.results"))
  (.size (filter :compile mut))
  (reduce + 0 (map :fitness mut))
#+end_src

**** normalized likely GP with longer patterns not weighted
just like the above but longer patterns are no longer weighted by the
square of the pattern length

after 1000 runs of each GP operation
|     | successful compile | total fitness | graph fitness |
|-----+--------------------+---------------+---------------|
| mut |                250 |          1190 |               |
| inj |                669 |          2739 |               |
| swp |                192 |            11 |               |
| del |                409 |             0 |               |

This data is saved in =gp-operations= and can be loaded and inspected
with lines like...
#+begin_src clojure :tangle no
  (def mut (read-obj "./gp-operations/mut.normalized.results"))
  (.size (filter :compile mut))
  (reduce + 0 (map :fitness mut))
#+end_src

** Fitness of Nearby variants
   :PROPERTIES:
   :session:  asm-gp
   :END:

#+begin_src clojure
  (load-file "src/asm-gp.clj")(in-ns 'asm-gp)
  (def fixed (read-asm (f/file-str "~/research/code/fixed.s")))
  (def near-inj
       (pmap
        (fn [el] (evaluate (inj-asm fixed)))
        (range 1000)))
  (def near-del
       (pmap
        (fn [el] (evaluate (del-asm fixed)))
        (range 1000)))
  (def near-swp
       (pmap
        (fn [el] (evaluate (swp-asm fixed)))
        (range 1000)))
  (dorun near-inj)
  (dorun near-del)
  (dorun near-swp)
#+end_src

#+source: near-solution
#+begin_src clojure
  (map
   (fn [n] (list n
                 (.size (filter #(= % n) near-del))
                 (.size (filter #(= % n) near-inj))
                 (.size (filter #(= % n) near-swp))))
   (range 11))
#+end_src

#+results: near-solution
|  0 | 661 | 689 | 840 |
|  1 |   0 |   1 |   1 |
|  2 |   0 |   1 |   2 |
|  3 |   0 |   0 |   0 |
|  4 |   0 |   2 |   0 |
|  5 | 227 | 120 | 124 |
|  6 |  11 |   6 |   7 |
|  7 |   0 |   2 |   0 |
|  8 |   0 |   0 |   0 |
|  9 |   1 |   0 |   0 |
| 10 | 100 | 179 |  26 |

#+begin_src gnuplot :var data=near-solution
  set xrange [-1:12]
  plot data using 1:2 title "del", data using 1:3 title "inj", data using 1:4 title "swp"
#+end_src

[[file:data/near-solution.png]]

** Simple GP
The goal here is to get some baseline performance numbers.  This run
will only use swap (0.25 percent) and crossover (0.25 percent).

*** method
    :PROPERTIES:
    :tangle: test/simple-gp
    :results:  silent
    :session:  asm-gp
    :END:

The following steps are tangled to the =test-simple-gp.clj= script
which can be run using
#+begin_src sh :tangle no
  java -cp ../../src/clojure/clojure.jar:../../src/clojure-contrib/clojure-contrib.jar clojure.main test/simple-gp.clj
#+end_src

1) create the =gcd.s= file
   #+begin_src sh :tangle no
     gcc -S gcd.c
   #+end_src
2) load the resulting file and step into the namespace
   #+begin_src clojure
     (load-file "src/asm-gp.clj")(in-ns 'asm-gp)
   #+end_src
3) load up the baseline individual
   #+begin_src clojure
     (def baseline (read-asm (f/file-str "~/research/code/gcd.s")))
   #+end_src
4) setup the GP parameters
   #+begin_src clojure
     (def mut-prob 0.1)
     (def del-prob 0.1)
     (def inj-prob 0.1)
     (def swp-prob 0.1)
     (def crossover-perc 0.25)
     (def max-generations 50)
     (def population-size 100)
     (def tournament-size 3)
   #+end_src
5) run 40 populations
   #+begin_src clojure
     (dorun
      (map  (fn [run]
              (do
                (evolve baseline)
                (let [save-dir (str "variants/" (.toString run))]
                  (s/sh "mkdir" save-dir)
                  (s/sh "./pack" save-dir))))
            (range 100)))
   #+end_src

*** results
**** pinyon section-based, swap, inj and crossover
    :PROPERTIES:
    :CUSTOM_ID: simple-gp-pinyon-sect-swp-crs
    :END:
ran into an "out-of-memory" error after 41 generations -- probably due
to the cache of fitness values ([[pinyon-section-swp-crs-memory-error]])

run at git commit: basically this was just when everything started
working well using [[section-based-gp-ops]]
#+begin_example
  commit b31500d8f2c68e846daa011971f324ebbdf1d592
  Author: Eric Schulte <schulte.eric@gmail.com>
  Date:   Wed Dec 30 13:50:17 2009 -0700
  
      only checking STDOUT (not STDERR) of test-*.sh scripts (better fitness scores)
#+end_example

9/41 or 21.95% of the runs found a solution in under 50 generations.

the distribution of generations-to-solution looks like
: (3 3 5 11 13 13 21 26 32)
with the majority of successes occurring in *under* 25 of the 50
possible generations.

those solutions which were found look to be real working solutions
#+begin_example 
  Script started on Fri 01 Jan 2010 04:10:56 PM MST
  sh-4.0$ gcc -o 9 variants/9/best.s
  sh-4.0$ ./9 0 55
  55
  sh-4.0$ ./9 8767 653
  1
  sh-4.0$ ./9 555 666
  111
  sh-4.0$ ./9 2 4
  2
  sh-4.0$ exit
  
  Script done on Fri 01 Jan 2010 04:11:44 PM MST
#+end_example

***** raw data

each run with the number of generations before solution pulled from
the following eshell line
: for i in variants/* {echo $i; ls $i | wc}
#+results: number-of-generations
|  0 | 50 |
|  1 | 50 |
|  2 | 50 |
|  3 | 21 |
|  4 | 50 |
|  5 | 50 |
|  6 | 50 |
|  7 | 50 |
|  8 | 13 |
|  9 |  3 |
| 10 | 50 |
| 11 | 50 |
| 12 | 50 |
| 13 |  5 |
| 14 | 50 |
| 15 | 50 |
| 16 | 50 |
| 17 | 50 |
| 18 | 26 |
| 19 | 50 |
| 20 | 32 |
| 21 | 50 |
| 22 | 50 |
| 23 | 50 |
| 24 | 50 |
| 25 | 50 |
| 26 | 50 |
| 27 | 50 |
| 28 | 13 |
| 29 | 50 |
| 30 |  3 |
| 31 | 50 |
| 32 | 50 |
| 33 | 50 |
| 34 | 50 |
| 35 | 50 |
| 36 | 50 |
| 37 | 50 |
| 38 | 11 |
| 39 | 50 |
| 40 | 50 |

#+begin_src clojure :session asm-gp :var data=number-of-generations
  (def data data)
#+end_src

***** error
      :PROPERTIES:
      :CUSTOM_ID: pinyon-section-swp-crs-memory-error
      :END:

#+begin_example
  generation 38
  Exception in thread "main" java.lang.RuntimeException: java.lang.RuntimeException: java.util.concurrent.ExecutionException: java.lang.OutOfMemoryError: Java heap space (test-simple-gp.clj:0)
          at clojure.lang.Compiler.eval(Compiler.java:4658)
          at clojure.lang.Compiler.load(Compiler.java:4972)
          at clojure.lang.Compiler.loadFile(Compiler.java:4939)
          at clojure.main$load_script__7423.invoke(main.clj:211)
          at clojure.main$script_opt__7460.invoke(main.clj:263)
          at clojure.main$main__7484.doInvoke(main.clj:338)
          at clojure.lang.RestFn.invoke(RestFn.java:413)
          at clojure.lang.Var.invoke(Var.java:359)
          at clojure.lang.AFn.applyToHelper(AFn.java:173)
          at clojure.lang.Var.applyTo(Var.java:476)
          at clojure.main.main(main.java:37)
  Caused by: java.lang.RuntimeException: java.lang.RuntimeException: java.util.concurrent.ExecutionException: java.lang.OutOfMemoryError: Java heap space
          at clojure.lang.LazySeq.sval(LazySeq.java:47)
          at clojure.lang.LazySeq.seq(LazySeq.java:56)
          at clojure.lang.ChunkedCons.chunkedNext(ChunkedCons.java:59)
          at clojure.lang.ChunkedCons.next(ChunkedCons.java:43)
          at clojure.lang.RT.next(RT.java:570)
          at clojure.core$next__4238.invoke(core.clj:50)
          at clojure.core$dorun__5263.invoke(core.clj:2098)
          at asm_gp$eval__163.invoke(test-simple-gp.clj:29)
          at clojure.lang.Compiler.eval(Compiler.java:4642)
          ... 10 more
  Caused by: java.lang.RuntimeException: java.util.concurrent.ExecutionException: java.lang.OutOfMemoryError: Java heap space
          at clojure.lang.LazySeq.sval(LazySeq.java:47)
          at clojure.lang.LazySeq.seq(LazySeq.java:56)
          at clojure.lang.Cons.next(Cons.java:37)
          at clojure.lang.RT.length(RT.java:1120)
          at clojure.lang.RT.seqToArray(RT.java:1099)
          at clojure.lang.LazySeq.toArray(LazySeq.java:126)
          at clojure.lang.RT.toArray(RT.java:1077)
          at clojure.core$to_array__4289.invoke(core.clj:257)
          at clojure.core$sort__5230.invoke(core.clj:1990)
          at clojure.core$sort_by__5234.invoke(core.clj:2003)
          at clojure.core$sort_by__5234.invoke(core.clj:2001)
          at asm_gp$evolve__92.invoke(asm-gp.clj:207)
          at asm_gp$eval__163$fn__165.invoke(test-simple-gp.clj:25)
          at clojure.core$map__5071$fn__5073.invoke(core.clj:1776)
          at clojure.lang.LazySeq.sval(LazySeq.java:42)
          ... 18 more
  Caused by: java.util.concurrent.ExecutionException: java.lang.OutOfMemoryError: Java heap space
          at java.util.concurrent.FutureTask$Sync.innerGet(FutureTask.java:252)
          at java.util.concurrent.FutureTask.get(FutureTask.java:111)
          at clojure.core$future_call__7236$fn__7251.invoke(core.clj:4482)
          at clojure.core.proxy$java.lang.Object$IDeref$Future$2b9be1f9.deref(Unknown Source)
          at clojure.core$deref__4891.invoke(core.clj:1467)
          at clojure.core$pmap__7267$step__7276$fn__7278.invoke(core.clj:4517)
          at clojure.lang.LazySeq.sval(LazySeq.java:42)
          ... 32 more
  Caused by: java.lang.OutOfMemoryError: Java heap space
          at java.util.ArrayList.<init>(ArrayList.java:132)
          at java.util.ArrayList.<init>(ArrayList.java:139)
          at clojure.lang.Reflector.getMethods(Reflector.java:312)
          at clojure.lang.Reflector.invokeNoArgInstanceMember(Reflector.java:263)
          at clojure.contrib.shell_out$stream_seq__2979$fn__2984.invoke(shell_out.clj:37)
          at clojure.core$repeatedly__6024$fn__6026.invoke(core.clj:3484)
          at clojure.lang.LazySeq.sval(LazySeq.java:42)
          at clojure.lang.LazySeq.seq(LazySeq.java:56)
          at clojure.lang.RT.seq(RT.java:440)
          at clojure.core$seq__4254.invoke(core.clj:103)
          at clojure.core$take_while__5120$fn__5122.invoke(core.clj:1843)
          at clojure.lang.LazySeq.sval(LazySeq.java:42)
          at clojure.lang.LazySeq.seq(LazySeq.java:56)
          at clojure.lang.RT.seq(RT.java:440)
          at clojure.core$seq__4254.invoke(core.clj:103)
          at clojure.core$map__5071$fn__5073.invoke(core.clj:1770)
          at clojure.lang.LazySeq.sval(LazySeq.java:42)
          at clojure.lang.LazySeq.seq(LazySeq.java:56)
          at clojure.lang.Cons.next(Cons.java:37)
          at clojure.lang.RT.next(RT.java:570)
          at clojure.core$next__4238.invoke(core.clj:50)
          at clojure.core$str__4340$fn__4344.invoke(core.clj:365)
          at clojure.core$str__4340.doInvoke(core.clj:367)
          at clojure.lang.RestFn.applyTo(RestFn.java:144)
          at clojure.core$apply__4379.invoke(core.clj:434)
          at clojure.contrib.shell_out$sh__3015$iter__3040__3044$fn__3045$fn__3047.invoke(shell_out.clj:129)
          at clojure.contrib.shell_out$sh__3015$iter__3040__3044$fn__3045.invoke(shell_out.clj:127)
          at clojure.lang.LazySeq.sval(LazySeq.java:42)
          at clojure.lang.LazySeq.seq(LazySeq.java:56)
          at clojure.lang.RT.seq(RT.java:440)
          at clojure.lang.RT.nth(RT.java:802)
          at clojure.contrib.shell_out$sh__3015.doInvoke(shell_out.clj:122)
#+end_example
**** pinyon line-based, swap, inj and crossover
     :PROPERTIES:
     :CUSTOM_ID: simple-gp-pinyon-line-swp-crs
     :END:
single-line GP operations, only using the swap and crossover
operations, run at git commit
#+begin_example 
  commit fd99c4a39b5ed78939dc4949028f1b21ae4bd969
  Author: Eric Schulte <schulte.eric@gmail.com>
  Date:   Mon Jan 4 07:47:53 2010 -0700
  
      now setup for a GP run with single-line operations
#+end_example

Success in 28/84 or 1/3 or 33.33% of the runs.

***** raw data
1) number of generations per try found with
   : for i in variants/* {echo $i; ls $i |wc}
2) saved to [[file:data/pinyon.single-line.munge][pinyon.single-line.munge]] then converted with the following
   macro
   #+begin_src emacs-lisp
     (fset 'munge
        [?\C-s ?/ ?\C-f ?\C-b ?\C-  ?\C-e ?\C-b ?\C-w ?\C-a ?\C-y ?\C-k ?\C-a ?\C-n backspace ?\C-a ?\C-n])
   #+end_src
3) imported to the following table with `org-table-import'

#+results: line-based-number-of-generations
|  0 | 51 |
|  1 |  2 |
|  2 |  7 |
|  3 | 51 |
|  4 | 51 |
|  5 | 22 |
|  6 | 15 |
|  7 | 51 |
|  8 | 51 |
|  9 | 51 |
| 10 | 27 |
| 11 | 51 |
| 12 | 51 |
| 13 | 51 |
| 14 | 51 |
| 15 |  3 |
| 16 | 51 |
| 17 | 51 |
| 18 | 51 |
| 19 | 51 |
| 20 | 51 |
| 21 | 51 |
| 22 | 45 |
| 23 | 15 |
| 24 | 51 |
| 25 | 37 |
| 26 | 51 |
| 27 |  2 |
| 28 | 51 |
| 29 | 51 |
| 30 | 51 |
| 31 | 51 |
| 32 | 51 |
| 33 | 51 |
| 34 | 51 |
| 35 | 51 |
| 36 |  2 |
| 37 |  7 |
| 38 | 51 |
| 39 | 23 |
| 40 | 51 |
| 41 | 51 |
| 42 |  3 |
| 43 | 51 |
| 44 | 51 |
| 45 |  4 |
| 46 | 51 |
| 47 | 22 |
| 48 | 51 |
| 49 | 18 |
| 50 | 51 |
| 51 | 45 |
| 52 | 51 |
| 53 | 51 |
| 54 | 51 |
| 55 | 51 |
| 56 | 51 |
| 57 | 51 |
| 58 | 51 |
| 59 | 11 |
| 60 | 51 |
| 61 | 32 |
| 62 |  8 |
| 63 | 51 |
| 64 | 51 |
| 65 | 27 |
| 66 | 51 |
| 67 | 15 |
| 68 |  2 |
| 69 | 51 |
| 70 | 51 |
| 71 | 51 |
| 72 | 51 |
| 73 | 51 |
| 74 | 51 |
| 75 | 18 |
| 76 | 14 |
| 77 | 51 |
| 78 | 51 |
| 79 | 51 |
| 80 | 51 |
| 81 |  5 |
| 82 | 51 |
| 83 |  8 |

#+begin_src clojure :var data=line-based-number-of-generations :session asm-gp
  (def data data)
#+end_src

#+results:
: #'user/data

**** pinyon line-based, inj, del and crossover

** Weighted GP
*** method
    :PROPERTIES:
    :tangle: test/weighted-gp
    :results:  silent
    :session:  asm-gp
    :END:

The following steps are tangled to the =test/weighted-gp.clj= script
which can be run using
#+begin_src sh :tangle no
  java -cp ../../src/clojure/clojure.jar:../../src/clojure-contrib/clojure-contrib.jar clojure.main test/weighted-gp.clj
#+end_src

1) create the =gcd.s= file
   #+begin_src sh :tangle no
     gcc -S gcd.c
   #+end_src
2) load the resulting file and step into the namespace
   #+begin_src clojure
     (load-file "src/asm-gp.clj")(in-ns 'asm-gp)
   #+end_src
3) load up the weighted bad path
   #+begin_src clojure
     (def bad-path
          (reduce
           (fn [a f] (let [val (get a f 0)]
                       (if (> val 1)
                         (assoc a f (dec val))
                         (dissoc a f))))
           (reduce (fn [a f] (assoc a f (inc (get a f 0)))) {}
                   (map #(Integer/parseInt %) (f/read-lines "data/bad.path")))
           (map #(Integer/parseInt %) (f/read-lines "data/good.path"))))
   #+end_src
4) doctor the weighted path -- logarithm and 1D Gaussian smoothing
   #+begin_src clojure
     (def bad-path
          (reduce ;; log of the weights
           #(assoc %1 (first %2) (m/log (inc (second %2)))) {}
           ;; 1D Gaussian Smoothing of weights
           (let [kernel {-3 0.006, -2 0.061, -1 0.242, 0 0.383, 1 0.242, 2 0.061, 3 0.006}]
             (reduce ;; for each weighted element of the bad-path
              (fn [accum el]
                (reduce ;; for each part of the Gaussian kernel
                 #(let [place (+ (first el) (first %2))]
                    (assoc %1 place 
                           (+ (get %1 place 0)
                              (* (second %2) (second el)))))
                 accum kernel)) {}
                 bad-path))))
   #+end_src
5) generate a good path
   #+begin_src clojure :session asm-gp
     (def good-path
          (reduce
           (fn [a f] (let [val (get a f 0)]
                       (if (> val 1)
                         (assoc a f (dec val))
                         (dissoc a f))))
           (reduce (fn [a f] (assoc a f (inc (get a f 0)))) {}
                   (map #(Integer/parseInt %) (f/read-lines "data/good.path")))
           (map #(Integer/parseInt %) (f/read-lines "data/bad.path"))))
   #+end_src
6) doctor the good path
   #+begin_src clojure
     (def good-path
          (reduce ;; log of the weights
           #(assoc %1 (first %2) (m/log (inc (second %2)))) {}
           ;; 1D Gaussian Smoothing of weights
           (let [kernel {-3 0.006, -2 0.061, -1 0.242, 0 0.383, 1 0.242, 2 0.061, 3 0.006}]
             (reduce ;; for each weighted element of the good-path
              (fn [accum el]
                (reduce ;; for each part of the Gaussian kernel
                 #(let [place (+ (first el) (first %2))]
                    (assoc %1 place 
                           (+ (get %1 place 0)
                              (* (second %2) (second el)))))
                 accum kernel)) {}
                 good-path))))
   #+end_src
7) load up the baseline individual
   #+begin_src clojure
     (def baseline
          (apply-path
           (apply-path (read-asm "gcd.s")
                       :good-weight good-path)
           :bad-weight bad-path))
   #+end_src
8) setup the GP parameters
   #+begin_src clojure
     (def mut-prob 0.0)
     (def del-prob 0.0)
     (def inj-prob 0.25)
     (def swp-prob 0.0)
     (def crossover-perc 0.25)
     (def max-generations 50)
     (def population-size 100)
     (def tournament-size 3)
   #+end_src
9) run 40 populations
   #+begin_src clojure
     (dorun
      (map  (fn [run]
              (do
                (evolve baseline)
                (let [save-dir (str "variants/" (.toString run))]
                  (s/sh "mkdir" save-dir)
                  (s/sh "./pack" save-dir))))
            (range 100)))
   #+end_src

*** results
Succeeded in 51/100 trials, so better than half.

**** raw
| run | failed? |
|-----+---------|
|   0 |       1 |
|   1 |         |
|   2 |       1 |
|   3 |       1 |
|   4 |         |
|   5 |         |
|   6 |       1 |
|   7 |       1 |
|   8 |       1 |
|   9 |       1 |
|  10 |         |
|  11 |         |
|  12 |         |
|  13 |         |
|  14 |       1 |
|  15 |         |
|  16 |         |
|  17 |       1 |
|  18 |       1 |
|  19 |       1 |
|  20 |       1 |
|  21 |       1 |
|  22 |         |
|  23 |         |
|  24 |       1 |
|  25 |         |
|  26 |       1 |
|  27 |         |
|  28 |         |
|  29 |         |
|  30 |       1 |
|  31 |       1 |
|  32 |       1 |
|  33 |       1 |
|  34 |         |
|  35 |         |
|  36 |         |
|  37 |         |
|  38 |       1 |
|  39 |         |
|  40 |       1 |
|  41 |         |
|  42 |       1 |
|  43 |       1 |
|  44 |       1 |
|  45 |         |
|  46 |         |
|  47 |       1 |
|  48 |       1 |
|  49 |       1 |
|  50 |         |
|  51 |         |
|  52 |       1 |
|  53 |         |
|  54 |         |
|  55 |       1 |
|  56 |       1 |
|  57 |         |
|  58 |         |
|  59 |       1 |
|  60 |         |
|  61 |       1 |
|  62 |         |
|  63 |         |
|  64 |       1 |
|  65 |         |
|  66 |         |
|  67 |       1 |
|  68 |         |
|  69 |         |
|  70 |         |
|  71 |         |
|  72 |         |
|  73 |       1 |
|  74 |         |
|  75 |       1 |
|  76 |         |
|  77 |         |
|  78 |       1 |
|  79 |         |
|  80 |       1 |
|  81 |       1 |
|  82 |         |
|  83 |       1 |
|  84 |       1 |
|  85 |         |
|  86 |       1 |
|  87 |       1 |
|  88 |       1 |
|  89 |       1 |
|  90 |         |
|  91 |       1 |
|  92 |         |
|  93 |       1 |
|  94 |         |
|  95 |       1 |
|  96 |         |
|  97 |       1 |
|  98 |         |
|  99 |         |
|-----+---------|
|     |      49 |
#+TBLFM: @102$2=vsum(@2..@-1)

** VU's Challenge
   - State "STARTED"    from "TODO"       [2010-01-08 Fri 15:43]
Trying VU's challenge script which genprog is unable to solve.  It's
just like the gcd.c example only *two* lines of the original C
source-code need to be changed
#+begin_src C
    b=b+1;              //         <=  fix 1: delete this line   
    printf("%g\n", b);  //         <=  fix 2: insert return 0; to
#+end_src

This seems to be difficult for genprog because
1) genprog normally can only solve single-line changes
2) genprog is unable to distinguish between test-failure due to
   segfault or infinite-loop (fix 1 above), and the less onerous
   failures due to incorrect output (fix 2 above)

This will try basically the same method as with weighted-gp stuff, and
to help solve this problem ASM-GP can now [[diff-between-bad-and-worse][differentiate between bad
and worse failures]].

This approach was able to solve the above challenge problem in 3/100
tries, I /think/ that's probably better than the success rate for
normal genprog.

#+begin_example 
  $ ls variants
  0   12  16  2   23  27  30  34  38  41  45  49  52  56  6   63  67  70  74  78  81  85  89  92  96
  1   13  17  20  24  28  31  35  39  42  46  5   53  57  60  64  68  71  75  79  82  86  9   93  97
  10  14  18  21  25  29  32  36  4   43  47  50  54  58  61  65  69  72  76  8   83  87  90  94  98
  11  15  19  22  26  3   33  37  40  44  48  51  55  59  62  66  7   73  77  80  84  88  91  95  99
  $ find variants -name "best.s"
  variants/28/best.s
  variants/70/best.s
  variants/90/best.s
  $ 
#+end_example

*** method
    :PROPERTIES:
    :tangle: test/vu-challenge
    :results:  silent
    :session:  asm-gp
    :END:

The following steps are tangled to the =test/vu-challenge.clj= script
which can be run using
#+begin_src sh :tangle no
  java -cp ../../src/clojure/clojure.jar:../../src/clojure-contrib/clojure-contrib.jar clojure.main test/vu-challenge.clj
#+end_src

1) first compile the program and build the good and bad paths by hand
   #+begin_src sh :tangle no
     gcc -S challenge.c
     gcc -o challenge challenge.s
     gdb challenge -batch -x data/bad-profile.gdb |clj mem-to-asm.clj challenge.s > data/challenge-bad.path
     gdb challenge -batch -x data/good-profile.gdb |clj mem-to-asm.clj challenge.s > data/challenge-good.path
   #+end_src
2) load up asm-gp and step into the namespace
   #+begin_src clojure
     (load-file "src/asm-gp.clj")(in-ns 'asm-gp)
   #+end_src
3) load up the weighted bad path
   #+begin_src clojure
     (def bad-path
          (reduce
           (fn [a f] (let [val (get a f 0)]
                       (if (> val 1)
                         (assoc a f (dec val))
                         (dissoc a f))))
           (reduce (fn [a f] (assoc a f (inc (get a f 0)))) {}
                   (map #(Integer/parseInt %) (f/read-lines "data/challenge-bad.path")))
           (map #(Integer/parseInt %) (f/read-lines "data/challenge-good.path"))))
   #+end_src
4) doctor the weighted path -- logarithm and 1D Gaussian smoothing
   #+begin_src clojure
     (def bad-path
          (reduce ;; log of the weights
           #(assoc %1 (first %2) (m/log (inc (second %2)))) {}
           ;; 1D Gaussian Smoothing of weights
           (let [kernel {-3 0.006, -2 0.061, -1 0.242, 0 0.383, 1 0.242, 2 0.061, 3 0.006}]
             (reduce ;; for each weighted element of the bad-path
              (fn [accum el]
                (reduce ;; for each part of the Gaussian kernel
                 #(let [place (+ (first el) (first %2))]
                    (assoc %1 place 
                           (+ (get %1 place 0)
                              (* (second %2) (second el)))))
                 accum kernel)) {}
                 bad-path))))
   #+end_src
5) generate a good path
   #+begin_src clojure :session asm-gp
     (def good-path
          (reduce
           (fn [a f] (let [val (get a f 0)]
                       (if (> val 1)
                         (assoc a f (dec val))
                         (dissoc a f))))
           (reduce (fn [a f] (assoc a f (inc (get a f 0)))) {}
                   (map #(Integer/parseInt %) (f/read-lines "data/challenge-good.path")))
           (map #(Integer/parseInt %) (f/read-lines "data/challenge-bad.path"))))
   #+end_src
6) doctor the good path
   #+begin_src clojure
     (def good-path
          (reduce ;; log of the weights
           #(assoc %1 (first %2) (m/log (inc (second %2)))) {}
           ;; 1D Gaussian Smoothing of weights
           (let [kernel {-3 0.006, -2 0.061, -1 0.242, 0 0.383, 1 0.242, 2 0.061, 3 0.006}]
             (reduce ;; for each weighted element of the good-path
              (fn [accum el]
                (reduce ;; for each part of the Gaussian kernel
                 #(let [place (+ (first el) (first %2))]
                    (assoc %1 place 
                           (+ (get %1 place 0)
                              (* (second %2) (second el)))))
                 accum kernel)) {}
                 good-path))))
   #+end_src
7) load up the baseline individual
   #+begin_src clojure
     (def baseline
          (apply-path
           (apply-path (read-asm "challenge.s")
                       :good-weight good-path)
           :bad-weight bad-path))
   #+end_src
8) setup the GP parameters
   #+begin_src clojure
     (def mut-prob 0.0)
     (def del-prob 0.25)
     (def inj-prob 0.25)
     (def swp-prob 0.0)
     (def crossover-perc 0.25)
     (def max-generations 50)
     (def population-size 100)
     (def tournament-size 3)
   #+end_src
9) run 40 populations
   #+begin_src clojure
     (dorun
      (map  (fn [run]
              (do
                (evolve baseline)
                (let [save-dir (str "variants/" (.toString run))]
                  (s/sh "mkdir" save-dir)
                  (s/sh "./pack" save-dir))))
            (range 100)))
   #+end_src
*** results
*** bugs
running into a null pointer exception, not sure where

#+begin_example
  generation 0 best-score 5
  Exception in thread "main" java.lang.RuntimeException: java.lang.RuntimeException: java.lang.RuntimeException: java.util
  .concurrent.ExecutionException: java.lang.NullPointerException (vu-challenge.clj:0)
          at clojure.lang.Compiler.eval(Compiler.java:4543)
          at clojure.lang.Compiler.load(Compiler.java:4857)
          at clojure.lang.Compiler.loadFile(Compiler.java:4824)
          at clojure.main$load_script__5833.invoke(main.clj:206)
          at clojure.main$script_opt__5864.invoke(main.clj:258)
          at clojure.main$main__5888.doInvoke(main.clj:333)
          at clojure.lang.RestFn.invoke(RestFn.java:413)
          at clojure.lang.Var.invoke(Var.java:346)
#+end_example
